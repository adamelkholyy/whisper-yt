import os 
import json
import re
import yt_dlp
from whisper_yt.utilities import segment_audio_from_transcript

def download_and_preprocess_yt(url: str, download_dir="downloads", output_dir="data"):
    """
    Pipeline to perform the following:
        1) Download audio mp3 and subtitles transcript from a youtube video given its url
        2) Process the raw transcript 
        3) Split audio into segments from transcript 
        4) Create transcript.json containing audio segment and transcript data
    Args:
        url (str): Youtube video URL
        download_dir (str, optional): directory to save downloaded audio and transcript. Defaults to 'downloads'
        output_dir (str, optional: directory to save segmented audio. Defaults to 'data'
    Returns:
        None
    """
    # download mp3 and raw transcript
    download_mp3(url, download_dir=download_dir)
    download_info = download_transcript(url, download_dir=download_dir)

    # process raw transcript (either manual or auto-generated)
    if download_info["manual"]: 
        process_manual_transcript(input_dir=download_dir, output_dir=output_dir, transcript_filename=download_info["transcript_filename"])
    else: 
        process_autogenerated_transcript(input_dir=download_dir, output_dir=output_dir, transcript_filename=download_info["transcript_filename"])

    # split audio into segments from transcript
    mp3_path = os.path.join(download_dir, "audio.mp3")
    transcript_path = os.path.join(output_dir, "transcript.json")
    segment_audio_from_transcript(transcript_path, mp3_path=mp3_path, output_dir=output_dir)


def download_mp3(url: str, download_dir='downloads', audio_filename='audio'):
    """
    Downloads the audio (.mp3) of youtube video given its URL 
    Args:
        url (str): Youtube video url 
        download_dir (str): directory for mp3 file download. Defaults to 'downloads'
        audio_filename (str): name of the mp3 file. Defaults to 'audio'
    Returns:
        None
    """
    os.makedirs(download_dir, exist_ok=True)
    audio_output_path = os.path.join(download_dir, audio_filename)

    # download arguments for ytl_dlp 
    ydl_opts = {
        'format': 'bestaudio/best',  
        'outtmpl': audio_output_path,  
        'postprocessors': [{  # force mp3 filetype
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '192',
        }],
        'noplaylist': True,  
    }

    # download mp3 file
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])

    print(f"[yt_downloader] Audio download complete, MP3 saved at {audio_output_path}")


def download_transcript(url: str, lang="en", download_dir="downloads"):
    """
    Downloads the raw subtitle transcript from the given youtube url
    Args:
        url (str): Youtube video url 
        lang (str, optional): language for transcript. Defaults to "en"
        download_dir (str, optional): output directory for downloaded raw transcript. Defaults to "downloads"
    Returns:
        download_info (dict): dictionary containing 2 keys
            - "manual" (bool): indicates whether transcript is manual or auto-generated
            - "transcript_filename" (str): raw transcript filename
    """
    transcript_filename = "raw_transcript"
    transcript_filename_ext = f"{transcript_filename}.{lang}.vtt"
    os.makedirs(download_dir, exist_ok=True)
    transcript_output_path = os.path.join(download_dir, transcript_filename)

    # download arguments for ytl_dlp 
    ydl_opts = {
        'skip_download': True,
        'writesubtitles': True, # download manual transcription 
        'writeautomaticsub': False,
        'subtitlesformat': 'vtt',
        'subtitleslangs': [lang],
        'outtmpl': transcript_output_path,
        'noplaylist': True,
    }
   
    # attempt to download manual subtitles
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])

    # if transcript.vtt exists then manual subtitles were downloaded successfully 
    if any(file.endswith('.vtt') for file in os.listdir(download_dir)):
        print(f"[yt_downloader] Manual subtitles downloaded, raw transcript saved to {transcript_filename_ext}")
        return {"manual": True, "transcript_filename": transcript_filename_ext}

    # otherwise there are no manual subs; download auto-generated subs instead
    print(f"[yt_downloader] Manual subtitles not found, downloading auto-generated subtitles")
    ydl_opts['writesubtitles'] = False
    ydl_opts['writeautomaticsub'] = True  

    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])

    print(f"[yt_downloader] Auto-generated subtitles downloaded, raw transcript saved to {transcript_filename_ext}")
    return {"manual": False, "transcript_filename": transcript_filename_ext}


def timestamp_to_milliseconds(timestamp: str):
    """
    Converts a timestamp string in the form 00:00:00.000 into milliseconds
    Args:
        timestamp (str): timestamp in string form 
    Returns:
        total_milliseconds (int): timestamp converted into milliseconds
    """
    # regex to extract digits from timestamp
    pattern = r"(\d{2}):(\d{2}):(\d{2})\.(\d{3})"
    match = re.match(pattern, timestamp)
    hours, minutes, seconds, milliseconds = map(int, match.groups())
    total_milliseconds = (hours * 3600 * 1000) + (minutes * 60 * 1000) + (seconds * 1000) + milliseconds
    return total_milliseconds

    
def process_manual_transcript(input_dir="downloads", output_dir="data", transcript_filename="raw_transcript.en.vtt"):
    """
    Processes the raw manual transcript vtt file and extracts timestamped text (in ms) to a file (transcript.json)
    Args:
        input_dir (str, optional): path to directory containing raw transcript. Defaults to 'downloads'
        output_dir (str, optional): path to directory to output transcript.json. Defaults to 'data'
        transcript_filename (str, optional): raw transcript filename. Defaults to raw_transcript.en.vtt
    Returns:
        None
    """
    raw_transcript_path = os.path.join(input_dir, transcript_filename)
    with open(raw_transcript_path, 'r') as file:
        content = file.read()

    # text processing for manual yt .vtt transcripts 
    content = content.replace("\n ", "")
    content = content.split("\n\n")
    extracted_data = [group.split("\n")[:3] for group in content if len(group.split("\n")) > 1][1:]
    transcript = []

    # regex for timestamps in the form 00:00:00.00
    pattern = r"\d+:\d+:\d*\.\d+"

    # extracts timestamps and text and converts to milliseconds for transcript.json
    for data in extracted_data: 
        start_timestamp, end_timestamp = re.findall(pattern, data[0])

        # format subtitle line
        text = "".join([data[i]+ " " for i in range(1, len(data))])[:-1]
        transcript.append({"start": timestamp_to_milliseconds(start_timestamp),"end": timestamp_to_milliseconds(end_timestamp), "text":text})

    # save as transcript.json 
    os.makedirs(output_dir, exist_ok=True)
    transcript_json_path = os.path.join(output_dir, "transcript.json")
    with open(transcript_json_path, 'w') as json_file:
        json.dump(transcript, json_file, indent=2)

    print(f"[yt_downloader] Raw manual transcript successfully processed and written to {transcript_json_path}")

   
def process_autogenerated_transcript(input_dir="downloads", output_dir="data", transcript_filename="raw_transcript.en.vtt"):
    """
    Processes the raw auto-generated transcript vtt file and extracts timestamped text (in ms) to transcript.json
    Args:
        input_dir (str, optional): path to directory containing raw transcript. Defaults to 'downloads'
        output_dir (str, optional): path to directory to output transcript.json. Defaults to 'data'
        transcript_filename (str, optional): raw transcript filename. Defaults to raw_transcript.en.vtt
    Returns:
        None
    """
    raw_transcript_path = os.path.join(input_dir, transcript_filename)
    with open(raw_transcript_path, 'r') as file:
        content = file.read()

    # text processing for auto-generated yt .vtt transcripts 
    initial_timestamps = content.split("\n")[4]
    content = content.replace("\n ", "")
    content = content.split("\n\n")
    extracted_data = [group.split("\n")[:2] for group in content if len(group.split("\n")) > 2][1:]
    transcript = []

    # regex for timestamps in the form 00:00:00.00
    pattern = r"\d+:\d+:\d*\.\d+"

    # extract timestamps for first line of audio 
    start_timestamp, end_timestamp = re.findall(pattern, initial_timestamps)

    # extracts timestamps and text and converts to milliseconds for transcript.json
    for (timestamp_data, text) in extracted_data: 
        transcript.append({"start": timestamp_to_milliseconds(start_timestamp),"end": timestamp_to_milliseconds(end_timestamp), "text": text})
        start_timestamp, end_timestamp = re.findall(pattern, timestamp_data)
            
    # save as transcript.json 
    os.makedirs(output_dir, exist_ok=True)
    transcript_json_path = os.path.join(output_dir, "transcript.json")
    with open(transcript_json_path, 'w') as json_file:
        json.dump(transcript, json_file, indent=2)

    print(f"[yt_downloader] Raw auto-generated transcript successfully processed and written to {transcript_json_path}")



if __name__ == "__main__":
    video_url = "https://www.youtube.com/watch?v=ac5Jct33oUU"
    download_mp3(video_url)
    download_transcript(video_url)
    transcript = process_manual_transcript()

