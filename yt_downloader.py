import os 
import json
import re
import yt_dlp


def download_mp3(url: str, download_dir='downloads', audio_filename='audio'):
    os.makedirs(download_dir, exist_ok=True)
    audio_output_path = os.path.join(download_dir, audio_filename)

    ydl_opts = {
        'format': 'bestaudio/best',  
        'outtmpl': audio_output_path,  
        'postprocessors': [{  # force mp3 filetype
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '192',
        }],
        'noplaylist': True,  
    }

    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])
    print(f"[yt_downloader] Audio download complete, MP3 saved at {audio_output_path}")


def download_transcript(url: str, lang="en", download_dir="downloads", output_dir='data', process_transcript=True):
    transcript_filename = "raw_transcript"
    transcript_filename_ext = f"{transcript_filename}.{lang}.vtt"
    os.makedirs(download_dir, exist_ok=True)
    transcript_output_path = os.path.join(download_dir, transcript_filename)

    ydl_opts = {
        'skip_download': True,
        'writesubtitles': True,
        'writeautomaticsub': False,
        'subtitlesformat': 'vtt',
        'subtitleslangs': [lang],
        'outtmpl': transcript_output_path,
        'noplaylist': True,
    }
   
    # attempt to download manual subtitles
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])

    # if transcript exists then manual subtitles were downloaded successfully 
    if any(file.endswith('.vtt') for file in os.listdir(download_dir)):
        print(f"[yt_downloader] Manual subtitles downloaded, raw transcript saved to {transcript_filename_ext}")
        return process_manual_transcript(input_dir=download_dir, output_dir=output_dir, transcript_filename=transcript_filename_ext) if process_transcript else None

    # otherwise there are no manual subs; download auto-generated subs instead
    print(f"[yt_downloader] Manual subtitles not found, downloading auto-generated subtitles")
    ydl_opts['writesubtitles'] = False
    ydl_opts['writeautomaticsub'] = True  

    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])

    print(f"[yt_downloader] Auto-generated subtitles downloaded, raw transcript saved to {transcript_filename_ext}")
    return process_autogenerated_transcript(input_dir=download_dir, output_dir=output_dir, transcript_filename=transcript_filename_ext) if process_transcript else None 


def timestamp_to_milliseconds(timestamp: str):
    pattern = r"(\d{2}):(\d{2}):(\d{2})\.(\d{3})"
    match = re.match(pattern, timestamp)
    hours, minutes, seconds, milliseconds = map(int, match.groups())
    total_milliseconds = (hours * 3600 * 1000) + (minutes * 60 * 1000) + (seconds * 1000) + milliseconds
    return total_milliseconds

    
def process_manual_transcript(input_dir="downloads", output_dir="data", transcript_filename="raw_transcript.en.vtt"):
    raw_transcript_path = os.path.join(input_dir, transcript_filename)
    with open(raw_transcript_path, 'r') as file:
        content = file.read()

    # todo: comment about yt transcript files handling start weirdly
    content = content.replace("\n ", "")
    content = content.split("\n\n")
    extracted_data = [group.split("\n")[:3] for group in content if len(group.split("\n")) > 2][1:]
    transcript = []

    pattern = r"\d+:\d+:\d*\.\d+"

    for (timestamp_data, line1, line2) in extracted_data: 
        start_timestamp, end_timestamp = re.findall(pattern, timestamp_data)
        transcript.append({"start": timestamp_to_milliseconds(start_timestamp),"end": timestamp_to_milliseconds(end_timestamp), "text": line1 + " " + line2})

    os.makedirs(output_dir, exist_ok=True)
    transcript_json_path = os.path.join(output_dir, "transcript.json")
    with open(transcript_json_path, 'w') as json_file:
        json.dump(transcript, json_file, indent=2)

    print(f"[yt_downloader] Raw manual transcript successfully processed and written to {transcript_json_path}")

   
def process_autogenerated_transcript(input_dir="downloads", output_dir="data", transcript_filename="raw_transcript.en.vtt"):
    raw_transcript_path = os.path.join(input_dir, transcript_filename)
    with open(raw_transcript_path, 'r') as file:
        content = file.read()

    # todo: comment about yt transcript files handling start weirdly
    initial_timestamps = content.split("\n")[4]
    content = content.replace("\n ", "")
    content = content.split("\n\n")
    extracted_data = [group.split("\n")[:2] for group in content if len(group.split("\n")) > 2][1:]
    transcript = []

    pattern = r"\d+:\d+:\d*\.\d+"
    start_timestamp, end_timestamp = re.findall(pattern, initial_timestamps)

    for (timestamp_data, text) in extracted_data: 
        transcript.append({"start": timestamp_to_milliseconds(start_timestamp),"end": timestamp_to_milliseconds(end_timestamp), "text": text})
        start_timestamp, end_timestamp = re.findall(pattern, timestamp_data)
            
    os.makedirs(output_dir, exist_ok=True)
    transcript_json_path = os.path.join(output_dir, "transcript.json")
    with open(transcript_json_path, 'w') as json_file:
        json.dump(transcript, json_file, indent=2)

    print(f"[yt_downloader] Raw auto-generated transcript successfully processed and written to {transcript_json_path}")



if __name__ == "__main__":
    video_url = "https://www.youtube.com/watch?v=VatNBZh66Po"
    download_mp3(video_url)
    download_transcript(video_url)
    transcript = process_manual_transcript()
    for t in transcript: print(f"[yt_downloader] {t}")


